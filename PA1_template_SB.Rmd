---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
---


## 1. Loading and preprocessing the data

```{r, include = FALSE}
rm(list = ls())
library(tidyverse)
library(magrittr)
library(readr)
library(knitr)
```



```{r}
# Set the URL of the zip file
url <- "https://github.com/rdpeng/RepData_PeerAssessment1/raw/master/activity.zip"

# Set the destination file name
destfile <- "activity.zip"

# Download the zip file
download.file(url, destfile, quiet = TRUE)

# Extract the activity.csv file
unzip(destfile, "activity.csv")

# Load the data into R
mydat <- read.csv("activity.csv")
```


```{r}
mydat %>% head()
```


### 1.1 Initial Exploratory Data Analysis

- Initial glimpse of the data

```{r}
mydat %>% glimpse
```

- NA values per column:

```{r}
mydat %>% is.na() %>% colSums()
```


- Determining the number of unique values per column.

  - there are 61 unique dates
  - there are 288 unique intervals (5-minute periods)

```{r}
for (i in 1:3){
  print(mydat %>% select(all_of(i)) %>% unique() %>% nrow())
}
```

- It would be helpful to identify how the missing values are dispersed within the dataframe. Is it localized to only a few dates, or scattered through all of the days?
- is it localized to specific minute intervals?

Reshaping the data, looks like the missing values are all on specific dates.

```{r}
# new
mydat %>% 
      pivot_wider(names_from = interval, values_from = steps) %>%
      is.na() %>% 
      rowSums()
```


The reshaped data is stored as 'mydata'.

```{r}
#new
mydata = mydat %>% 
      pivot_wider(names_from = interval, values_from = steps) %>% 
      mutate(date = as.Date(date), 
            daily_stepsums = rowSums(select_if(., is.numeric))) %>% 
      select(daily_stepsums, everything())
mydata %>% head()
```




- to identify the dates that correspond to having all missing values:

```{r}
# can omit
mydat %>% 
      pivot_wider(names_from = interval, values_from = steps) %>% 
      mutate(num_missing = rowSums(select_if(., is.numeric)),
      date = as.Date(date)) %>% 
      select(num_missing, everything()) %>% 
      # displaying only the missing rows
      filter(is.na(num_missing))
```





```{r}
mydat %>% 
      pivot_wider(names_from = interval, values_from = steps) %>% 
      mutate(num_missing = rowSums(select_if(., is.numeric))) %>% 
      pull(num_missing) %>% 
      mean(na.rm = TRUE)
```


- Determining where the missing values are located.

Of the 2304 missing values for the steps column, it turns out that they are not scattered throughout the data, but the missing data are all on 8 specific days (288*8 = 2304 missing vals). The missing days are identified in the code chunk below.


```{r}
missing_days <- mydat %>% 
  pivot_wider(names_from = interval, values_from = steps) %>% 
  mutate(missing_vals_perday = rowSums(is.na(.))) %>% 
  select(date, missing_vals_perday, everything()) %>% 
  filter(missing_vals_perday != 0)
```

  - The days for which we have NAs are displayed in missing_days$date below.

```{r}
missing_days
```


```{r}
missing_days$date
```


## Q1: What is mean total number of steps taken per day?

#### 1.1 Calculate the total number of steps taken per day

We already have the daily_stepsums variable created earlier; we calculate the mean to get the mean total steps.


```{r}
#new
mydata %>% 
      pull(daily_stepsums) %>% 
      mean(na.rm = TRUE)
```


$can probably leave out the following$

There are 61 days total for this data. But per the initial EDA, 8 days of data are fully missing (variable: missing_days), and there are actually 53 days of data.

So number of days can be 61 including the missing days, or 53 excluding the missing days.

Total number of steps is 570608.

```{r}
total_steps <- mydat$steps %>% sum(na.rm = TRUE)
total_steps
```

- Total steps per day are as follows. The NAs correspond to the days for which data are missing.
  
```{r}
TotalSteps_perDay <- mydat %>% 
  pivot_wider(names_from = interval, values_from = steps) %>% 
  mutate(date = as.Date(date), steps_perday = rowSums(select(., -date))) %>% 
  select(date, steps_perday)
TotalSteps_perDay %>% head()
```
The mean steps per day are 10766.19.


```{r}
TotalSteps_perDay %>% 
  summarise(meanSteps_perDay = mean(steps_perday, na.rm = TRUE))
```
$Note:$

The above mean is based on 53 days, as data for the remaining days are missing. (Using number of days as 61, the mean total number of steps would be 9354.23)

#### 1.2 histogram of the total number of steps taken each day

For this, we need to plot daily_stepsums against date.

```{r, warning = FALSE}
#new
mydata %>% 
      ggplot(aes(date, daily_stepsums)) + 
      geom_histogram(stat = 'identity', fill = 'steelblue') +
      labs(x = "Date", y = "Total Steps per Day") +
      scale_x_date(date_labels = "%m/%d", date_breaks = "7 days") +
      theme(axis.text.x = element_text(angle = 45, hjust=1)) + 
      ggtitle("Total Steps per Day from Oct 1, 2012 to Nov 30, 2012")
```

$can probably ignore the rest$

```{r}
steps_eachday <- mydat %>% 
  pivot_wider(names_from = interval, values_from = steps) %>% 
  mutate(date = as.Date(date), steps_perday = rowSums(select(., -date))) %>% 
  select(date, steps_perday)
steps_eachday %>% head()
```

- For the purpose of plotting the histogram, the missing values are replaced with zeros.


```{r, warning=FALSE}
steps_eachday %>% 
  replace_na(list(steps_perday = 0)) %>% 
  ggplot(aes(date, steps_perday)) +
  geom_histogram(stat = "identity", fill = "steelblue") +
  labs(x = "Date", y = "Total Steps per Day") +
  scale_x_date(date_labels = "%m/%d", date_breaks = "7 days") +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) + 
  ggtitle("Total Steps per Day from Oct 1, 2012 to Nov 30, 2012")
```


#### 1.3 mean and median of the total number of steps taken per day

This information is obtained using the summarize() function on the daily_stepsums column


### something might be wrong in this step, as i think we are supposed to find the mean steps per day, not the overall mean steps.

```{r}
#new
mydata %>% 
      summarize(median_steps = median(daily_stepsums, na.rm = TRUE),
                mean_steps = mean(daily_stepsums, na.rm = TRUE))
```
```{r}
mydat
```

```{r}
mydat %>% 
      pivot_wider(names_from = interval, values_from = steps) %>% 
      mutate(mean_steps = rowMeans(select(., -date), na.rm = TRUE)) %>% 
      select(date, mean_steps)
```
### major issue - not being able to get rid of null values

understandable, as some dates do not have any values at all

```{r}
mydat %>% 
      pivot_wider(names_from = interval, values_from = steps) %>% 
      mutate(mean_steps = rowMeans(across(-date), na.rm = TRUE, dims = 1)) %>% 
      select(date, mean_steps)
```
```{r}
mydat %>% 
      group_by(date) %>% 
      mean(steps, na.rm = TRUE)
```



```{r}
#nope
mydat %>% 
      mutate(date = as.Date(date)) %>% 
      group_by(date) %>% 
      summarize(meansteps = round(mean(steps), 2), 
                mediansteps = round(median(steps), 2)) 
```







$can leave this out$

Mean and median total steps per day are calculated as follows.

```{r}
steps_eachday %>% 
  summarize(mean_total_steps = mean(steps_perday, na.rm = TRUE),
            median_total_steps = median(steps_perday, na.rm = TRUE))
```


## Q2. What is the average daily activity pattern?

#### Q2.2 Make a time series plot of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all days (y-axis)

$new approach$

For plotting the time series of the 5-min intervals and the average number of steps, it is helpful to arrange the data differently.

```{r}
mydat2 <- mydat %>% 
      pivot_wider(names_from = date, values_from = steps)
mydat2 %>% head()
```

Taking the row means while leaving out the interval column gives the desired output. 

```{r}
mydat2_intervals <- mydat2 %>% 
      mutate(interval_means = round(rowMeans(select(.,-interval), 
                                             na.rm = TRUE), 2)) %>% 
      select(interval, interval_means)
```

Also, the true interval is in time units while our dataframe above, the column 'interval' is of type int. To fix this, we create a function that converts this column to time units, and use this to update the data type of the interval column.


```{r}
tohours_3 <- function(data){
  hour = floor(data/100)
  min = sprintf("%02d", data %% 100)
  time_str = parse_time(paste0(hour, ":", min))
  return (time_str)
}
```


```{r}
mydat2_intervals <-  mydat2_intervals %>% 
      mutate(interval = tohours_3(interval))
mydat2_intervals %>% head()
```
```{r}
mydat2_intervals %>% 
      ggplot(aes(interval, interval_means)) + geom_line(color = 'steelblue')+
      theme(axis.text.x = element_text(angle = 45, hjust=1))
      #scale_x_date(date_breaks = '%H%M')
#scale_x_date(date_labels = "%m/%d", date_breaks = "7 days")
```
```{r}
mydat2_intervals %>% 
  ggplot(aes(x = interval, y = interval_means)) + 
  geom_line(lwd = 1, color = "steelblue") +
  labs(x = "Interval    (x-axis label is in Hours)", 
       y = "Mean Steps per 5-min interval") +
  ggtitle("Time Series plot for Mean Steps per 5-minute Interval")
```


$old approach$ let this stay for now but delete later on before submitting


- First, we arrange the data so as to determine the mean steps per 5-min interval. The key step is to use the pivot_wider() function, followed by appropriate summarization of the relevant columns.

In determining the mean steps the division is by the number of available days of data, 53 days.


```{r}
# final version
meanSteps_perInterval <- mydat %>% 
  pivot_wider(names_from = date, values_from = steps) %>% 
  mutate(total_steps_5min = rowSums(select(.,-interval), na.rm = TRUE)) %>% 
  mutate(mean_steps_5min = round(total_steps_5min/53, 2)) %>% 
  select(interval, mean_steps_5min)
meanSteps_perInterval %>% head()
```
```{r}
meanSteps_perInterval %>% head(20)
```

- If we look at the interval column, it still shows discontinuity; for example after 55, the next number is 100. To address this, a function is created, tohours_3(), that takes in numeric data and outputs the data in period format with hours:minutes:seconds, and with the correction for discontinuity.


```{r}
tohours_3 <- function(data){
  hour = floor(data/100)
  min = sprintf("%02d", data %% 100)
  time_str = parse_time(paste0(hour, ":", min))
  return (time_str)
}
```


- Finally, we update the interval column with the function tohours_3() shows the appropriate intervals in time format (hms).


```{r}
meanSteps_per_Interval <- meanSteps_perInterval %>% 
  mutate(interval = tohours_3(interval))
meanSteps_per_Interval
```


- The plot is made using ggplot2, with the x-axis hsowing the Intervals (the labels are in hours) and the y-axis shows the mean steps per 5-min interval.


```{r}
meanSteps_per_Interval %>% 
  ggplot(aes(x = interval, y = mean_steps_5min)) + 
  geom_line(lwd = 1, color = "steelblue") +
  labs(x = "Interval    (x-axis label is in Hours)", 
       y = "Mean Steps per 5-min interval") +
  ggtitle("Time Series plot for Mean Steps per 5-minute Interval")
```


#### Q2.2 5-minute interval containing the maximum number of steps

new:

```{r}
mydat2_intervals %>% 
      filter(interval_means == max(interval_means))
```


old - delete this one:

The maximum number of steps is at 8:35AM.

```{r}
meanSteps_per_Interval %>% 
  filter(mean_steps_5min == max(mean_steps_5min))
```

## Q3. Imputing missing values


#### 3.1  Total number of missing values in the dataset (i.e. the total number of rows with NAs)

It is seen that only missing values (NAs) are in the steps column.

```{r}
mydat %>% is.na() %>% colSums()
```


#### 3.2 Devise a strategy for filling in all of the missing values in the dataset. 

$Strategy$

- Each of the missing values correspond to an interval and a day of week.

- It can be envisioned that the missing values for the steps taken for a particular 5min interval could be approximated reasonably well if we use the mean steps for 
      - the same day of the week, and 
      - the same 5-minute interval.

- It is expected that the missing value will have substantial similarity to the values corresponding to the same time of the day and the same day of the week. 

- Therefore, the strategy is to create a dataframe with the means of each weekday and interval combinations, and then use these values to impute the missing values corresponding to the same weekday and interval combinations.

#### 3.3  Create a new dataset that is equal to the original dataset but with the missing data filled in.



#### Implementation of Strategy

To accomplish this, we first build the dataframe imputedf, which is the dataframe we are going to impute from. For this, from the original data, we convert the dates to weekdays, group by weekday and interval, and get the corresponding means.


```{r, message = FALSE}
imputedf <- mydat %>% 
      mutate(interval = tohours_3(interval)) %>% 
      mutate(wkday = weekdays(as.Date(date))) %>% 
      select(-date) %>% group_by(wkday, interval) %>% 
      summarize(mean_steps = round(mean(steps, na.rm = TRUE), 2))
#imputedf %>% head()
```

For each combination of wkday and interval, we have an associated mean, mean_steps. An example is shown below:

```{r}
imputedf %>% 
      filter(interval == 00:00:00 & wkday == 'Monday')
```

For the dataframe we are going to impute missing values for, we add a weekday column, so that we can join by weekday and interval.

```{r}
mydata3 <- mydat %>% 
      mutate(interval = tohours_3(interval)) %>% 
      mutate(wkday = weekdays(as.Date(date)))
mydata3 %>% head()
```

And finally,  

- imputedf is left-joined with mydata3:
      - making sure only those with missing values are imputed
      - interval and wkday columns match up (by = c('interval', 'wkday'))
- missing values are imputed using values from the mean_steps column
- the mean_steps and wkday columns are dropped to get back our imputed dataframe

The imputed new dataset is 'mydata3_imputed'

```{r}
# this seems to work
mydata3_imputed <- mydata3 %>% 
      left_join(imputedf, by = c('interval', 'wkday')) %>% 
      mutate(steps = if_else(is.na(steps), mean_steps, steps)) %>% 
      select(-mean_steps, -wkday)
mydata3_imputed %>% head()
```
At the end of the imputation, we are left with zero missing values.

```{r}
mydata3_imputed %>% is.na() %>% colSums()
```



#### 3.4.1 Make a histogram of the total number of steps taken each day

new:

The total number of steps taken per day can be calculated using our imputed data frame as follows:


```{r}
mydata3_imputed %>% 
      mutate(date = as.Date(date)) %>% 
      group_by(date) %>% 
      summarize(steps_perday = sum(steps)) %>% head()
```



```{r, warning=F}
mydata3_imputed %>% 
      mutate(date = as.Date(date)) %>% 
      group_by(date) %>% 
      summarize(steps_perday = sum(steps)) %>% 
      ggplot(aes(date, steps_perday)) +
      geom_histogram(stat = "identity", fill = "steelblue") +
      labs(x = "Date", y = "Total Steps per Day") +
      scale_x_date(date_labels = "%m/%d", date_breaks = "7 days") +
      theme(axis.text.x = element_text(angle = 45, hjust=1)) + 
      ggtitle("Total Steps per Day from Oct 1, 2012 to Nov 30, 2012")
```




old:

- Using the exact same steps as in question 1, our new dataframe imputed_df_2 was processed, which now has the steps_perday_imputed as the column with the imputed values of steps per day.

- For the sake of clarity, the steps per day in the original data with the missing values have been added to our dataframe as steps_perday_orig.


```{r}
steps_eachday_imputed <- imputed_df_2 %>% 
  pivot_wider(names_from = interval, values_from = steps) %>% 
  mutate(date = as.Date(date), steps_perday_imputed = rowSums(select(., -date))) %>% 
  select(date, steps_perday_imputed) %>% 
  mutate(steps_perday_orig = steps_eachday$steps_perday)
steps_eachday_imputed %>% head()
```
The histogram for the total number of steps taken each day is as plotted below.


```{r, warning = FALSE}
steps_eachday_imputed %>% 
  ggplot(aes(date, steps_perday_imputed)) +
  geom_histogram(stat = "identity", fill = "steelblue") +
  labs(x = "Date", y = "Total Steps (including imputed) per Day") +
  scale_x_date(date_labels = "%m/%d", date_breaks = "3 days") +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) + 
  ggtitle("Total Steps (with imputations) per Day from Oct 1, 2012 to Nov 30, 2012")
```

#### 3.4.2  Calculation of the mean and median total number of steps taken per day

new:


To find this, we write a function that groups the data by date and calculates the total steps taken per day. We then summarize with the mean and median total steps.

```{r}
perday_meansmedians <- function(data){
      updateddata = data %>% 
            group_by(date) %>% 
            summarize(total_steps = sum(steps)) %>%
            summarize(mean_totalsteps = mean(total_steps, na.rm = TRUE),
                      median_totalsteps = median(total_steps, na.rm = TRUE))
      return (updateddata)
}
```

Applying this function to the imputed dataframe:

```{r}
perday_meansmedians(mydata3_imputed)
```
And applying this to the original dataframe:

```{r}
perday_meansmedians(mydat)
```


```{r}
# this is the correct one, but having a function looks more slick
mydata3_imputed %>% 
      group_by(date) %>% 
      summarize(total_steps = sum(steps)) %>% 
      summarize(mean_totalsteps = mean(total_steps),
                median_totalsteps = median(total_steps))
```

And with the original dataframe, the mean and the medians are calculated using the same procedure as follows.

```{r}
mydat %>% 
      group_by(date) %>% 
      summarize(total_steps = sum(steps)) %>% 
      summarize(mean_totalsteps = mean(total_steps, na.rm = TRUE),
                median_totalsteps = median(total_steps, na.rm = TRUE))
```

```{r}
imputed_totaldailysteps <- mydata3_imputed %>% 
      group_by(date) %>% 
      summarize(totalsteps_imputed = sum(steps))
```




```{r}
original_totaldailysteps <- mydat %>% 
      group_by(date) %>% 
      summarize(totalsteps_original = sum(steps))
```





old:

- Using the dataframe created above, steps_eachday_imputed, we can calculate the means and medians of the imputed data. The results are enclosed in the dataframe 'Comparisons_Means_Medians' below.

- Since the original steps per day is also included in this dataframe, we can show the comparisons of the original means and medians to the computed means and medians below.

- The mean with imputes for total steps is 10821.11, while the original was 10766.19.

- The median with imputes for total steps is 11015.00 while the original was 10765.00.


```{r}
Comparisons_Means_Medians <- steps_eachday_imputed %>% 
  summarize(mean_total_steps_orig = mean(steps_perday_orig, na.rm = TRUE),
            median_total_steps_orig = median(steps_perday_orig, na.rm = TRUE),
            mean_total_steps_imputed = mean(steps_perday_imputed),
            median_total_steps_imputed = median(steps_perday_imputed)) %>% 
  select(mean_total_steps_orig, mean_total_steps_imputed,
         median_total_steps_orig, median_total_steps_imputed) %>% 
  pivot_longer(1:4, names_to = "Comparison of Means & Medians", values_to = "Values")
Comparisons_Means_Medians
```

#### 3.4.3 Do these values differ from the estimates from the first part of the assignment? 

new:

With the original data, when we summed the daily steps, since eight of the days were missing steps data, we had na's for some of the sums. In calculating the means and the medians, we had to remove the na values.

In contrast, with the imputed data frame, those 8 days have the imputed data, which involves approximations. The means and medians are then calculated with the full data including the imputations.

Thus, there is a difference in the mean and the median calculations with the imputed data, compared to the first part of the assignment. But the differences are small.




old:

- As seen from the comparison table above, the values do not differ by much from the estimates in the first part of the assignment. This is because of the following:
  - The imputation method used was a reasonable approach
  - In calculation of the means of the original data, the missing days were already accounted for (8 days with missing data), and only the days with available data were used in the calculation of the means.


#### 3.4.4 What is the impact of imputing missing data on the estimates of the total daily number of steps?

new:

Since the missing values are not scattered throughout the dataframe but are concentrated on specific days, the total daily steps only change for the days which had missing values, since an imputation is involved. For the remaining days which had no missing values, the total daily steps remain the same, as shown below.


```{r}
# total steps, with imputations
imputed_totaldailysteps <- mydata3_imputed %>% 
      group_by(date) %>% 
      summarize(totalsteps_imputed = sum(steps))
```


```{r}
# total steps - original
original_totaldailysteps <- mydat %>% 
      group_by(date) %>% 
      summarize(totalsteps_original = sum(steps))
```

A comparison of the first 6 rows are shown to demonstrate this.

```{r}
imputed_totaldailysteps %>% 
      left_join(original_totaldailysteps, by = 'date') %>% head()
```



Old:

As the table in section 3.4.2 shows, the total daily steps estimate with the imputes is 10821.22, while the original daily steps estimate was 10766.19.

The fact that these numbers are close likely shows that our method of imputing the missing values is a reasonable approach.

$Note:$

We could also calculate the means differently to reach the same numbers: Since the original data had steps information for only 53 of the 61 days, the total steps are divided by 53 below, while with the imputes, the division is by 61.


```{r}
steps_eachday_imputed %>% 
  summarize(totalDailySteps_withImputes = sum(steps_perday_imputed)/61,
            totalDailySteps_original = sum(steps_perday_orig, na.rm = TRUE)/53)
```


## Q4: Are there differences in activity patterns between weekdays and weekends?

#### 4.1 Create a new factor variable in the dataset with two levels – “weekday” and “weekend”

Below, we create the factor variable with the original data as well as the imputed data from the earlier steps.


```{r}
# with original data
mydata4 <- mydat %>% 
      mutate(dayofweek = weekdays(as.Date(date))) %>% 
      mutate(wknd = as.factor(
            if_else(dayofweek %in% c('Saturday',  'Sunday'), 
                    'weekend',
                    'weekday')))
mydata4 %>% head()
```
```{r}
# with imputed data
mydata5 <- mydata3_imputed %>% 
      mutate(dayofweek = weekdays(as.Date(date))) %>% 
      mutate(wknd = as.factor(
            if_else(dayofweek %in% c('Saturday',  'Sunday'), 
                    'weekend',
                    'weekday')))
mydata5 %>% head()
```



#### 4.2 Make a panel plot containing a time series plot of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all weekday days or weekend days (y-axis).


- To make the panel plots, we create two dataframes that show whether it is a weekday or a weekend, and the intervals, and corresponding mean steps for each.

- We do this with both the imputed data (without_missing) and the unimputed data (with_missing).

- Next, we left join to get the full dataframe.


```{r, message=F}
with_missing <- mydata4 %>% 
      mutate(interval = tohours_3(interval)) %>% 
      group_by(interval, wknd) %>% 
      summarize(wMissing = round(mean(steps, na.rm = TRUE), 2))
without_missing <- mydata5 %>% 
      #mutate(interval = tohours_3(interval)) %>% 
      group_by(wknd, interval) %>% 
      summarize(withoutMissing = round(mean(steps, na.rm = TRUE), 2))
# using left join to have all the data in the same dataframe
fulldata <- with_missing %>% 
      left_join(without_missing, by = c('interval', 'wknd')) %>% 
      pivot_longer(3:4, names_to = 'missing', 
                   values_to = 'mean_vals') %>% 
      mutate(missing = as.factor(missing))

fulldata %>% head()
```
Next, we make a panel plot with fulldata, the two panels representing the mean steps per interval on weekdays vs. on the weekends. 

In each of the plots, the imputed data is plotted in red, and the original data in green.

```{r}
fulldata %>% 
      ggplot(aes(interval, mean_vals, color = missing)) +
      geom_line(lwd = 1) +
      facet_grid(wknd~.) +
      labs(x = "Time in hours (at 5-min intervals)",
           y = "Average number of steps taken") +
      ggtitle("Average Steps per interval: Weekdays vs. the Weekend")
```


#### Differences between activity patterns during weekdays vs the weekends

Going through this data and making plots gave us an idea regarding the mean steps during weekday and weekends, at various hours.

  - Interestingly, imputation only made a slight difference in the number of steps taken during the weekday and negligible difference for the weekend, as seen by the near overlap of the red line representing with imputations and the blue line representing without imputations. The slight difference may be an indication that our imputation strategy is working well.
  - It looks like the activity during 8-9AM is much higher during weekdays, which is probably consistent with people going to work during these hours.
  - The mean activity between 10AM and 4PM appears to be higher during the weekends, consistent with people being out and about during the weekend instead of being at work during weekdays.
  - During the weekends, people seem to be more active in the evenings after 8PM, consistent with people staying up late during weekends.
  - From 5-8AM, and 4-6PM, there is considerably more activity during the week compared to weekends; this could be due to people getting ready to go to work or getting their exercise in the mornings/evenings, while more people are probably likely to sleep in during the weekend mornings.




